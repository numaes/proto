<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="md_README" kind="page">
    <compoundname>md_README</compoundname>
    <title>Proto Runtime Library</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="md_README_1autotoc_md11"/> The <computeroutput>proto</computeroutput> library is a high-performance runtime environment designed for programming languages, emphasizing immutable data structures, a flexible prototype-based object model, and an advanced concurrent garbage collection system.</para>
<sect1 id="md_README_1autotoc_md12">
<title>Key Features</title>
<sect2 id="md_README_1autotoc_md13">
<title>Immutable Data Structures</title>
<para><computeroutput>proto</computeroutput> provides core data structures that are inherently immutable, enhancing system safety and concurrency:</para>
<para><itemizedlist>
<listitem><para>**Lists (<computeroutput>ProtoList</computeroutput>):** Implemented as balanced trees, operations on lists return new instances rather than modifying the original, ensuring data persistence. Optimized for concurrent environments.</para>
</listitem><listitem><para>**Tuples (<computeroutput>ProtoTuple</computeroutput>):** Immutable collections similar to Python tuples. They are interned to optimize memory usage and comparisons, and are implemented using search trees for efficient access and slicing.</para>
</listitem><listitem><para>**Strings (<computeroutput>ProtoString</computeroutput>):** Immutable and built upon <computeroutput>ProtoTuple</computeroutput>, benefiting from the same immutability and deduplication optimizations. String operations also yield new string instances.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_README_1autotoc_md14">
<title>Prototype-Based Object Model</title>
<para>Inspired by languages like JavaScript and Self, <computeroutput>proto</computeroutput> features a dynamic and flexible object model:</para>
<para><itemizedlist>
<listitem><para>**Objects (<computeroutput>ProtoObjectCell</computeroutput>):** Objects link to a <computeroutput>parent</computeroutput> (prototype) and manage their <computeroutput>attributes</computeroutput> using a sparse list.</para>
</listitem><listitem><para><bold>Prototype-Based Inheritance:</bold> Objects inherit properties and methods from their <computeroutput>parent</computeroutput> objects, with attribute lookups traversing the prototype chain.</para>
</listitem><listitem><para><bold>Cloning and Child Creation:</bold> Objects can be cloned or new objects can be created that directly inherit from existing prototypes.</para>
</listitem><listitem><para><bold>Dynamic Attributes:</bold> Attributes can be added or modified dynamically.</para>
</listitem><listitem><para><bold>Method Calling:</bold> A robust mechanism for invoking object-associated functions through the prototype chain.</para>
</listitem><listitem><para><bold>Mutable Objects:</bold> While core data structures are immutable, the system supports mutable objects, with their visibility and collection safely managed by the concurrent GC.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_README_1autotoc_md15">
<title>Concurrent Memory Management and Garbage Collection (GC)</title>
<para>The <computeroutput>proto</computeroutput> runtime boasts a sophisticated memory management system designed for minimal overhead and high concurrency:</para>
<para><itemizedlist>
<listitem><para><bold>Cell-Based Allocation:</bold> All runtime objects are managed in fixed-size (64-byte) cells, eliminating fragmentation and enabling a fast, simple allocator.</para>
</listitem><listitem><para><bold>Per-Thread Memory Pools:</bold> Each thread maintains its own pool of free cells, allowing for near-instantaneous, lock-free memory allocation.</para>
</listitem><listitem><para><bold>Dedicated Concurrent GC:</bold> A dedicated GC thread (<computeroutput>gcThreadLoop</computeroutput>) operates in parallel with application threads, minimizing pauses.</para>
</listitem><listitem><para><bold>Hybrid GC (Partial Stop-the-World):</bold> The GC employs a brief &quot;stop-the-world&quot; phase to safely collect system roots (thread stacks, global references). The subsequent mark and sweep phases run concurrently with application execution, leveraging data immutability to ensure consistency.</para>
</listitem><listitem><para><bold>Optimized Short-Lived Object Cleanup:</bold> An asynchronous analysis pool efficiently reclaims memory from short-lived objects, acting as a generational collection mechanism.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md_README_1autotoc_md16">
<title>Building the Project</title>
<para>The project uses <computeroutput>make</computeroutput> for its build system.</para>
<sect2 id="md_README_1autotoc_md17">
<title>Prerequisites</title>
<para><itemizedlist>
<listitem><para><computeroutput>g++</computeroutput> (GCC C++ Compiler)</para>
</listitem><listitem><para><computeroutput>make</computeroutput></para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_README_1autotoc_md18">
<title>Compilation Instructions</title>
<para><orderedlist>
<listitem><para><bold>Clone the repository:</bold> <computeroutput>bash git clone &lt;repository_url&gt; cd proto </computeroutput></para>
</listitem><listitem><para><bold>Build the release version of the library:</bold> <computeroutput>bash make all </computeroutput> This will compile the <computeroutput>proto</computeroutput> library and create <computeroutput>lib/libproto.a</computeroutput>.</para>
</listitem><listitem><para><bold>Build the debug version of the library and the test executable:</bold> <computeroutput>bash make debug </computeroutput> This will compile the debug version of the library (<computeroutput>lib/libproto-debug.a</computeroutput>) and the <computeroutput>test_proto</computeroutput> executable located in <computeroutput>bin/</computeroutput>.</para>
</listitem><listitem><para><bold>Run the tests:</bold> <computeroutput>bash make test </computeroutput> This will execute the <computeroutput>bin/test_proto</computeroutput> program.</para>
</listitem><listitem><para><bold>Clean the build artifacts:</bold> <computeroutput>bash make clean </computeroutput> This will remove all compiled objects, debug files, and generated libraries. </para>
</listitem></orderedlist>
</para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="README.md"/>
  </compounddef>
</doxygen>
