<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="md_DESIGN" kind="page">
    <compoundname>md_DESIGN</compoundname>
    <title>Arquitectura de la Biblioteca Proto</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="md_DESIGN_1autotoc_md0"/> Esta biblioteca implementa un runtime para lenguajes de programación, con un fuerte enfoque en estructuras de datos inmutables, un modelo de objetos basado en prototipos y un sistema de gestión de memoria concurrente de alto rendimiento.</para>
<sect1 id="md_DESIGN_1autotoc_md1">
<title>Principios de Diseño</title>
<para>El núcleo de la biblioteca se basa en los siguientes principios:</para>
<para><orderedlist>
<listitem><para><bold>Inmutabilidad:</bold> Todas las estructuras de datos fundamentales (listas, tuplas, cadenas) son inmutables. Las modificaciones no alteran las estructuras existentes, sino que crean nuevas versiones con los cambios aplicados (copy-on-write). Esto simplifica enormemente la programación concurrente al eliminar la necesidad de locks complejos para proteger los datos.</para>
</listitem><listitem><para><bold>Gestión de Memoria Basada en Celdas:</bold> Toda la memoria para los objetos del runtime se gestiona a través de celdas de tamaño fijo (64 bytes). Este enfoque elimina la fragmentación de memoria y permite el uso de un asignador (allocator) extremadamente simple y rápido.</para>
</listitem><listitem><para><bold>Modelo de Objetos Basado en Prototipos:</bold> En lugar de clases tradicionales, el sistema utiliza un modelo de objetos basado en prototipos, donde los objetos heredan propiedades y comportamientos directamente de otros objetos.</para>
</listitem><listitem><para><bold>Alto Rendimiento y Concurrencia:</bold> El diseño está optimizado para sistemas multi-core, minimizando la contención de locks y maximizando el paralelismo.</para>
</listitem></orderedlist>
</para>
</sect1>
<sect1 id="md_DESIGN_1autotoc_md2">
<title>Gestión de Memoria y Garbage Collection (GC)</title>
<para>El sistema de gestión de memoria es uno de los componentes más críticos y sofisticados de la biblioteca.</para>
<sect2 id="md_DESIGN_1autotoc_md3">
<title>Asignador de Memoria (Allocator)</title>
<para><itemizedlist>
<listitem><para><bold>Pool por Thread:</bold> Cada thread del sistema operativo posee su propio pool de celdas de memoria libres. Cuando un thread necesita crear un nuevo objeto, toma una celda de su pool local.</para>
</listitem><listitem><para><bold>Asignación Rápida:</bold> Este diseño permite una asignación de memoria casi instantánea, ya que no requiere un lock global. La contención se minimiza, permitiendo que los threads se ejecuten en paralelo sin bloquearse mutuamente durante la creación de objetos.</para>
</listitem><listitem><para><bold>Obtención de Bloques:</bold> Si el pool local de un thread se agota, solicita un nuevo bloque de celdas al <computeroutput>ProtoSpace</computeroutput> global, que gestiona el heap principal. El <computeroutput>ProtoSpace</computeroutput> también es responsable de la asignación inicial de grandes bloques de memoria del sistema operativo.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_DESIGN_1autotoc_md4">
<title>Garbage Collector (GC) Concurrente</title>
<para>El GC está diseñado para minimizar las pausas y el impacto en el rendimiento de la aplicación.</para>
<para><itemizedlist>
<listitem><para><bold>Thread Dedicado:</bold> El GC se ejecuta en su propio thread (<computeroutput>gcThreadLoop</computeroutput> en <computeroutput><ref refid="ProtoSpace_8cpp" kindref="compound">ProtoSpace.cpp</ref></computeroutput>), operando en paralelo con los threads de la aplicación.</para>
</listitem><listitem><para>**Seguimiento de Asignaciones (<computeroutput>DirtySegment</computeroutput>):** Las celdas recién asignadas por los threads de la aplicación se encadenan en <computeroutput>DirtySegment</computeroutput>s, que son luego procesados por el GC. Esto permite al GC identificar eficientemente la memoria que necesita ser analizada.</para>
</listitem><listitem><para>**Sincronización de Threads (<computeroutput>synchToGC</computeroutput>):** Los threads de la aplicación utilizan el método <computeroutput>synchToGC</computeroutput> para coordinar con el GC. Durante una fase de &quot;stop-the-world&quot; parcial, los threads se detienen brevemente (<computeroutput>THREAD_STATE_STOPPED</computeroutput>) para permitir que el GC recolecte las raíces de forma segura.</para>
</listitem><listitem><para><bold>GC Híbrido (Stop-the-World Parcial):</bold> El GC no detiene el mundo por completo para todo su ciclo. La fase de &quot;stop-the-world&quot; es muy breve y se utiliza únicamente para recolectar de forma segura las <bold>raíces (roots)</bold> del sistema. Las raíces incluyen los stacks de todos los threads activos y las referencias globales (como los objetos mutables gestionados por <computeroutput>mutableRoot</computeroutput> en <computeroutput>ProtoSpace</computeroutput>).</para>
</listitem><listitem><para><bold>Fases Concurrentes de Mark and Sweep:</bold> Una vez que las raíces han sido recolectadas, las fases de marcado (<computeroutput>mark</computeroutput>) y limpieza (<computeroutput>sweep</computeroutput>) se ejecutan de forma concurrente mientras los threads de la aplicación continúan su ejecución. La inmutabilidad de los datos es clave aquí, ya que garantiza que las referencias entre objetos no cambiarán mientras el GC está trabajando.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_DESIGN_1autotoc_md5">
<title>Ciclo de Vida de los Objetos y Limpieza por Ámbito</title>
<para><itemizedlist>
<listitem><para><bold>Objetos de Corta Duración:</bold> La biblioteca implementa una optimización para objetos de corta duración. Cuando un método o función finaliza, todas las celdas de memoria que fueron asignadas dentro de su ámbito y que no son parte del valor de retorno explícito, se devuelven a un &quot;pool de análisis&quot;.</para>
</listitem><listitem><para><bold>Análisis Asíncrono:</bold> Los objetos en este pool son candidatos para ser liberados. El GC analiza de forma asíncrona estas celdas para asegurarse de que no haya ninguna referencia viva a ellas desde las raíces del sistema. Si no hay referencias, la celda se devuelve al pool global de celdas libres, lista para ser reutilizada.</para>
</listitem><listitem><para><bold>Eficiencia:</bold> Este mecanismo actúa como una forma de recolección generacional, permitiendo que la mayoría de los objetos (que suelen tener una vida corta) se recolecten de manera muy eficiente sin necesidad de un ciclo completo de mark-and-sweep sobre todo el heap.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md_DESIGN_1autotoc_md6">
<title>Estructuras de Datos Inmutables</title>
<para>El runtime <computeroutput>proto</computeroutput> proporciona implementaciones de estructuras de datos fundamentales que son inherentemente inmutables, lo que contribuye a la seguridad y la concurrencia del sistema.</para>
<sect2 id="md_DESIGN_1autotoc_md7">
<title>Listas (&lt;tt&gt;ProtoList&lt;/tt&gt;)</title>
<para><itemizedlist>
<listitem><para>Implementadas como árboles balanceados (posiblemente AVL o similar, dado el uso de <computeroutput>leftRotate</computeroutput>, <computeroutput>rightRotate</computeroutput> y <computeroutput>rebalance</computeroutput>).</para>
</listitem><listitem><para>Las operaciones como <computeroutput>appendFirst</computeroutput>, <computeroutput>appendLast</computeroutput>, <computeroutput>insertAt</computeroutput>, <computeroutput>setAt</computeroutput>, <computeroutput>removeAt</computeroutput>, <computeroutput>splitFirst</computeroutput>, <computeroutput>splitLast</computeroutput>, <computeroutput>removeFirst</computeroutput>, <computeroutput>removeLast</computeroutput> y <computeroutput>removeSlice</computeroutput> no modifican la lista original, sino que devuelven una nueva lista con los cambios. Esto garantiza la persistencia de la estructura de datos.</para>
</listitem><listitem><para>Optimizadas para acceso eficiente y modificaciones en entornos concurrentes.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_DESIGN_1autotoc_md8">
<title>Tuplas (&lt;tt&gt;ProtoTuple&lt;/tt&gt;)</title>
<para><itemizedlist>
<listitem><para>Representan colecciones inmutables de elementos, similares a las tuplas en Python.</para>
</listitem><listitem><para>Implementadas como árboles de búsqueda (posiblemente un árbol B o similar, dado el uso de <computeroutput>TupleDictionary</computeroutput> para la gestión de la raíz de tuplas y la deduplicación).</para>
</listitem><listitem><para>Las tuplas son internadas (<computeroutput>tupleRoot</computeroutput> en <computeroutput>ProtoSpace</computeroutput>), lo que significa que las tuplas idénticas comparten la misma instancia en memoria, optimizando el uso de memoria y las comparaciones.</para>
</listitem><listitem><para>Proporcionan acceso eficiente a los elementos y operaciones de slicing.</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="md_DESIGN_1autotoc_md9">
<title>Cadenas (&lt;tt&gt;ProtoString&lt;/tt&gt;)</title>
<para><itemizedlist>
<listitem><para>Las cadenas son inmutables y se construyen sobre <computeroutput>ProtoTuple</computeroutput>, lo que significa que se benefician de las optimizaciones de inmutabilidad y deduplicación de las tuplas.</para>
</listitem><listitem><para>Las operaciones de cadena como concatenación, inserción y eliminación también devuelven nuevas instancias de cadena.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md_DESIGN_1autotoc_md10">
<title>Modelo de Objetos Basado en Prototipos</title>
<para>El sistema <computeroutput>proto</computeroutput> implementa un modelo de objetos flexible y dinámico basado en prototipos, similar a JavaScript o Self.</para>
<para><itemizedlist>
<listitem><para>**Objetos (<computeroutput>ProtoObjectCell</computeroutput>):** Los objetos son representados por <computeroutput>ProtoObjectCellImplementation</computeroutput>, que contienen un enlace a su <computeroutput>parent</computeroutput> (prototipo) y un <computeroutput>ProtoSparseList</computeroutput> de <computeroutput>attributes</computeroutput>.</para>
</listitem><listitem><para><bold>Herencia Basada en Prototipos:</bold> Los objetos heredan propiedades y métodos de sus objetos <computeroutput>parent</computeroutput>. La búsqueda de atributos (<computeroutput>getAttribute</computeroutput>) recorre la cadena de prototipos hasta encontrar el atributo o llegar al final de la cadena.</para>
</listitem><listitem><para>**Clonación y Creación de Hijos (<computeroutput>clone</computeroutput>, <computeroutput>newChild</computeroutput>):** Los objetos pueden ser clonados (<computeroutput>clone</computeroutput>) para crear nuevas instancias con los mismos atributos, o se pueden crear nuevos objetos que hereden directamente de un prototipo existente (<computeroutput>newChild</computeroutput>).</para>
</listitem><listitem><para><bold>Atributos Dinámicos:</bold> Los atributos pueden ser añadidos o modificados dinámicamente en los objetos. Las operaciones <computeroutput>setAttribute</computeroutput> y <computeroutput>hasAttribute</computeroutput> gestionan estos atributos.</para>
</listitem><listitem><para>**Llamada a Métodos (<computeroutput>call</computeroutput>):** El mecanismo de llamada a métodos permite invocar funciones asociadas a objetos, resolviendo el método a través de la cadena de prototipos.</para>
</listitem><listitem><para><bold>Objetos Mutables:</bold> Aunque las estructuras de datos fundamentales son inmutables, el sistema soporta la noción de objetos mutables (<computeroutput>mutable_ref</computeroutput> en <computeroutput>ProtoObjectCellImplementation</computeroutput> y <computeroutput>mutableRoot</computeroutput> en <computeroutput>ProtoSpace</computeroutput>). Esto permite que ciertos objetos se comporten de manera mutable, mientras que el GC gestiona su visibilidad y recolección de forma segura en un entorno concurrente. </para>
</listitem></itemizedlist>
</para>
</sect1>
    </detaileddescription>
    <location file="DESIGN.md"/>
  </compounddef>
</doxygen>
